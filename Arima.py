# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LojXeSv08XdnjG9dM4PKXi9otW032vTj
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
import joblib

def load_and_filter_2024(file_path):
    """
    Charge le CSV en convertissant 'DateTime' en datetime,
    définit cette colonne comme index, trie le DataFrame,
    et filtre pour ne conserver que les données de l'année 2024.
    """
    df = pd.read_csv(file_path, sep=';', parse_dates=['DateTime'], dayfirst=True)
    df.dropna(subset=['DateTime'], inplace=True)
    df.set_index('DateTime', inplace=True)
    df.sort_index(inplace=True)
    # Filtrer pour l'année 2024 (sécurité)
    df = df[df.index.year == 2024]
    print("Min date :", df.index.min())
    print("Max date :", df.index.max())
    print("Nombre total de lignes :", len(df))
    return df

def split_data(series, train_ratio=0.8):
    """
    Divise la série en training et test.
    """
    n = len(series)
    train_end = int(n * train_ratio)
    train = series.iloc[:train_end]
    test = series.iloc[train_end:]
    return train, test

def train_arima(series, order=(1,1,1)):
    """
    Entraîne un modèle ARIMA sur la série fournie sans ajouter de tendance.
    Renvoie le modèle entraîné.
    """
    model = ARIMA(series, order=order)
    model_fit = model.fit()
    return model_fit

if __name__ == "__main__":
    file_path = 'data2024_datetime.csv'

    # Charger et filtrer les données pour 2024
    df = load_and_filter_2024(file_path)

    # Vérifier que la colonne 'Consommation' existe et la convertir en numérique
    if 'Consommation' not in df.columns:
        print("ERREUR : La colonne 'Consommation' est introuvable.")
        exit(1)
    df['Consommation'] = pd.to_numeric(df['Consommation'], errors='coerce')
    df.dropna(subset=['Consommation'], inplace=True)

    consumption = df['Consommation']

    # Diviser la série en training (80%) et test (20%)
    train, test = split_data(consumption, train_ratio=0.8)
    print(f"Total observations (2024) : {len(consumption)}")
    print(f"Training set : {len(train)} observations")
    print(f"Test set : {len(test)} observations")

    # Entraîner le modèle ARIMA sur le training set (sans trend)
    order = (1,1,1)  # Ajustez selon vos tests
    model_fit = train_arima(train, order=order)

    # Visualiser l'ajustement sur le training set
    fitted_values = model_fit.fittedvalues
    plt.figure(figsize=(12,7))
    plt.plot(train, label='Training Actual', color='blue')
    plt.plot(fitted_values, label='Fitted Values ARIMA', color='orange', linestyle='--')
    plt.title("Ajustement du modèle ARIMA sur le training set (2024)")
    plt.xlabel("DateTime")
    plt.ylabel("Consommation")
    plt.legend()
    plt.grid(True)
    plt.show()

    # Sauvegarder le modèle entraîné pour la phase de test
    joblib.dump(model_fit, 'best_arima_model.pkl')
    print("Modèle ARIMA entraîné et sauvegardé sous 'best_arima_model.pkl'.")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import joblib
from sklearn.metrics import mean_absolute_error, mean_squared_error

def load_and_filter_2024(file_path):
    """
    Charge le CSV en convertissant la colonne 'DateTime' en datetime (format ISO),
    définit cette colonne comme index, trie le DataFrame, et filtre pour ne conserver que les données de l'année 2024.
    """
    df = pd.read_csv(file_path, sep=';', parse_dates=['DateTime'], dayfirst=True)
    df.dropna(subset=['DateTime'], inplace=True)
    df.set_index('DateTime', inplace=True)
    df.sort_index(inplace=True)
    # Filtrer pour l'année 2024
    df = df[df.index.year == 2024]
    return df

def split_data(series, train_ratio=0.8):
    """
    Divise la série en deux ensembles : training et test.
    """
    n = len(series)
    train_end = int(n * train_ratio)
    train = series.iloc[:train_end]
    test = series.iloc[train_end:]
    return train, test

def mean_absolute_percentage_error(actual, forecast):
    """
    Calcule le MAPE (%).
    """
    actual, forecast = np.array(actual), np.array(forecast)
    return np.mean(np.abs((actual - forecast) / actual)) * 100

def evaluate_model(model_fit, actual_series, steps):
    """
    Réalise une prévision sur 'steps' périodes, aligne la prévision sur l'index du test,
    et calcule MAE et RMSE.
    """
    raw_forecast = model_fit.forecast(steps=steps)
    forecast_index = actual_series.index[:steps]
    forecast = pd.Series(raw_forecast.values, index=forecast_index, name='Forecast')
    mae = mean_absolute_error(actual_series.iloc[:steps], forecast)
    rmse = np.sqrt(mean_squared_error(actual_series.iloc[:steps], forecast))
    return forecast, mae, rmse

if __name__ == "__main__":
    file_path = 'data2024_datetime.csv'

    # Charger et filtrer les données pour l'année 2024
    df = load_and_filter_2024(file_path)

    # Vérifier la présence de la colonne "Consommation" et la convertir en numérique
    if 'Consommation' not in df.columns:
        print("ERREUR : La colonne 'Consommation' est introuvable.")
        exit(1)
    df['Consommation'] = pd.to_numeric(df['Consommation'], errors='coerce')
    df.dropna(subset=['Consommation'], inplace=True)

    consumption = df['Consommation']

    # Diviser la série en training et test (80/20)
    train, test = split_data(consumption, train_ratio=0.8)
    print(f"Total observations (2024) : {len(consumption)}")
    print(f"Training set : {len(train)} observations")
    print(f"Test set : {len(test)} observations")

    # Charger le modèle ARIMA entraîné (par exemple, 'best_arima_model.pkl')
    model_fit = joblib.load('best_arima_model.pkl')

    # Prévoir sur le test set
    steps = len(test)
    forecast, mae, rmse = evaluate_model(model_fit, test, steps=steps)
    mape = mean_absolute_percentage_error(test, forecast)

    print("=== Performance sur le test set ===")
    print(f"MAE  : {mae:.2f}")
    print(f"RMSE : {rmse:.2f}")
    print(f"MAPE : {mape:.2f}%")

    # Créer un DataFrame avec l'index (DateTime), la consommation réelle et la prévision
    results = pd.DataFrame({
        "Test Actual": test,
        "Forecast": forecast
    })
    results.to_excel("results_forecast.xlsx", index=True)
    print("Les résultats ont été exportés dans 'results_forecast.xlsx'.")

    # Visualiser les prévisions sur le test set
    plt.figure(figsize=(12,7))
    plt.plot(test, label='Test Actual', color='green')
    plt.plot(forecast, label='Forecast ARIMA', color='red', linestyle='--')
    plt.title("Prévision ARIMA sur le test set (2024)")
    plt.xlabel("DateTime")
    plt.ylabel("Consommation")
    plt.legend()
    plt.grid(True)
    plt.show()